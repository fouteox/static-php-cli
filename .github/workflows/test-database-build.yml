name: "Test - Database Build"

on:
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  OPENSSL_MAJOR_MINOR: "3.5"

jobs:
  check-and-sync:
    name: "Check service versions and sync"
    runs-on: ubuntu-latest
    outputs:
      build-matrix: ${{ steps.check.outputs.build-matrix }}
      should-build: ${{ steps.check.outputs.should-build }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download metadata-services.json from R2"
        id: download-metadata
        run: |
          if aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "Downloaded existing metadata-services.json"
          else
            echo "{}" > metadata-services.json
            echo "Created empty metadata-services.json"
          fi

      - name: "Check versions and generate build matrix"
        id: check
        run: |
          .github/scripts/services-metadata-manager.sh check-versions

  resolve-openssl:
    name: "Resolve OpenSSL version"
    runs-on: ubuntu-latest
    needs: [check-and-sync]
    if: needs.check-and-sync.outputs.should-build == 'true'
    outputs:
      openssl-version: ${{ steps.resolve.outputs.version }}
    steps:
      - name: "Resolve latest OpenSSL ${{ env.OPENSSL_MAJOR_MINOR }}"
        id: resolve
        run: |
          MAJOR_MINOR="${{ env.OPENSSL_MAJOR_MINOR }}"
          LATEST=$(curl -s "https://endoflife.date/api/openssl.json" | \
            jq -r ".[] | select(.cycle == \"$MAJOR_MINOR\") | .latest")

          if [[ -z "$LATEST" || "$LATEST" == "null" ]]; then
            echo "Failed to resolve OpenSSL version for $MAJOR_MINOR"
            exit 1
          fi

          echo "version=$LATEST" >> $GITHUB_OUTPUT
          echo "Resolved OpenSSL $MAJOR_MINOR -> $LATEST"

  build-openssl:
    name: "Build OpenSSL ${{ needs.resolve-openssl.outputs.openssl-version }}"
    runs-on: macos-latest
    needs: [resolve-openssl]
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Cache OpenSSL build"
        id: cache-openssl
        uses: actions/cache@v4
        with:
          path: /tmp/openssl-static
          key: openssl-${{ needs.resolve-openssl.outputs.openssl-version }}-macos-arm64

      - name: "Build OpenSSL ${{ needs.resolve-openssl.outputs.openssl-version }}"
        if: steps.cache-openssl.outputs.cache-hit != 'true'
        run: |
          OPENSSL_DIR="/tmp/openssl-static"
          OPENSSL_VERSION="${{ needs.resolve-openssl.outputs.openssl-version }}"
          mkdir -p "$OPENSSL_DIR"

          curl -fsSL -o "openssl-${OPENSSL_VERSION}.tar.gz" "https://www.openssl.org/source/openssl-${OPENSSL_VERSION}.tar.gz"
          tar xzf "openssl-${OPENSSL_VERSION}.tar.gz"
          cd "openssl-${OPENSSL_VERSION}"

          ./Configure darwin64-arm64-cc \
            --prefix="$OPENSSL_DIR" \
            --openssldir="$OPENSSL_DIR" \
            shared \
            no-tests \
            no-docs \
            no-atexit

          make
          make install_sw

  build-service:
    name: "Build ${{ matrix.service }} ${{ matrix.version }}"
    runs-on: macos-latest
    needs: [check-and-sync, resolve-openssl, build-openssl]
    if: needs.check-and-sync.outputs.should-build == 'true'
    timeout-minutes: 240
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      PREBUILT_OPENSSL_DIR: /tmp/openssl-static
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.check-and-sync.outputs.build-matrix) }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Restore OpenSSL from cache"
        uses: actions/cache@v4
        with:
          path: /tmp/openssl-static
          key: openssl-${{ needs.resolve-openssl.outputs.openssl-version }}-macos-arm64

      - name: "Setup dependencies"
        run: |
          # Function to install Homebrew packages only if not already installed
          brew_install_if_missing() {
            for package in "$@"; do
              if ! brew list --formula "$package" >/dev/null 2>&1; then
                echo "Installing $package..."
                brew install "$package"
              else
                echo "$package is already installed, skipping"
              fi
            done
          }

          # MySQL and MariaDB need bison and ninja
          if [[ "${{ matrix.service }}" == "mysql" || "${{ matrix.service }}" == "mariadb" ]]; then
            brew_install_if_missing bison pkg-config ninja
          fi

          # Redis and Valkey need GNU tools and Rust
          if [[ "${{ matrix.service }}" == "redis" || "${{ matrix.service }}" == "valkey" ]]; then
            brew_install_if_missing coreutils make llvm@18 cmake gnu-sed automake libtool wget rust
          fi

      - name: "Generate Build Timestamp"
        id: timestamp
        run: |
          echo "timestamp=$(date -u +"%Y%m%d%H%M%S")" >> $GITHUB_OUTPUT

      - name: "Build ${{ matrix.service }}"
        run: |
          .github/scripts/database-build.sh ${{ matrix.service }} ${{ matrix.version }}

      - name: "Upload archive to R2 and save checksum"
        run: |
          SERVICE="${{ matrix.service }}"
          VERSION="${{ matrix.version }}"
          MAJOR="${{ matrix.major }}"
          ARCH=$(uname -m)
          WORKDIR="$HOME/fadogen-build/${SERVICE}-${VERSION}"
          ORIGINAL_ARCHIVE="$WORKDIR/${SERVICE}-${VERSION}-macos-${ARCH}.tar.xz"

          if [[ ! -f "$ORIGINAL_ARCHIVE" ]]; then
            echo "[ERROR] Archive not found: $ORIGINAL_ARCHIVE"
            exit 1
          fi

          TIMESTAMP="${{ steps.timestamp.outputs.timestamp }}"
          ARCHIVE_NAME="${SERVICE}-${VERSION}-macos-${ARCH}-${TIMESTAMP}.tar.xz"
          cp "$ORIGINAL_ARCHIVE" "$ARCHIVE_NAME"

          # Calculate SHA512
          if command -v sha512sum >/dev/null 2>&1; then
            SHA512=$(sha512sum "$ARCHIVE_NAME" | awk '{print $1}')
          else
            SHA512=$(shasum -a 512 "$ARCHIVE_NAME" | awk '{print $1}')
          fi

          echo "Archive: $ARCHIVE_NAME ($(du -h "$ARCHIVE_NAME" | cut -f1))"
          echo "SHA512: $SHA512"

          # Upload to R2
          aws s3 cp "$ARCHIVE_NAME" \
            s3://${{ secrets.R2_BUCKET_NAME }}/"$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }}

          # Save checksum (format: service,version,major,sha512,filename)
          echo "${SERVICE},${VERSION},${MAJOR},${SHA512},${ARCHIVE_NAME}" > checksums-${SERVICE}-${VERSION}.txt
          echo "Checksum saved: ${SERVICE},${VERSION},${MAJOR},${SHA512},${ARCHIVE_NAME}"

      - name: "Upload checksums"
        uses: actions/upload-artifact@v4
        with:
          name: checksum-${{ matrix.service }}-${{ matrix.version }}
          path: checksums-${{ matrix.service }}-${{ matrix.version }}.txt
          retention-days: 1

  update-metadata:
    name: "Update metadata-services.json"
    runs-on: ubuntu-latest
    needs: [check-and-sync, build-service]
    if: needs.build-service.result == 'success'
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download metadata-services.json from R2"
        run: |
          if aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "Downloaded existing metadata-services.json"
          else
            echo "{}" > metadata-services.json
            echo "Created empty metadata-services.json"
          fi

      - name: "Download all checksum artifacts"
        uses: actions/download-artifact@v5
        with:
          pattern: checksum-*
          merge-multiple: true

      - name: "Update metadata"
        run: |
          # Consolidate all checksums
          ALL_CHECKSUMS=""
          if ls checksums-*.txt 2>/dev/null; then
            ALL_CHECKSUMS=$(cat checksums-*.txt 2>/dev/null | grep -v "^$")
          fi

          if [[ -z "$ALL_CHECKSUMS" ]]; then
            echo "[ERROR] No checksums found"
            exit 1
          fi

          # Update metadata
          echo "$ALL_CHECKSUMS" | .github/scripts/services-metadata-manager.sh update-metadata

          # Display updated metadata
          echo "=== Updated metadata-services.json ==="
          cat metadata-services.json

      - name: "Upload metadata-services.json to R2"
        run: |
          aws s3 cp metadata-services.json s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }}
          echo "Uploaded metadata-services.json to R2"

  cleanup-old-builds:
    name: "Cleanup old service builds"
    runs-on: ubuntu-latest
    needs: [check-and-sync, update-metadata]
    if: needs.check-and-sync.outputs.should-build == 'true'
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download updated metadata-services.json from R2"
        run: |
          aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }}
          echo "Downloaded updated metadata-services.json"

      - name: "Cleanup old builds"
        run: |
          BUILD_MATRIX='${{ needs.check-and-sync.outputs.build-matrix }}'

          echo "Starting cleanup of old service builds..."

          # Parse build matrix and cleanup each service-major version
          echo "$BUILD_MATRIX" | jq -r '.include[] | "\(.service),\(.major)"' | sort -u | while IFS=',' read -r service major; do
            echo "Cleaning up old builds for $service major version $major..."

            # Get the current filename from metadata
            CURRENT_FILENAME=$(jq -r ".\"$service\".\"$major\".filename // \"\"" metadata-services.json)

            if [[ -z "$CURRENT_FILENAME" ]]; then
              echo "  No current filename found in metadata for $service $major"
              continue
            fi

            echo "  Current file: $CURRENT_FILENAME"

            # List all files for this service-major pattern and delete all except the current one
            aws s3api list-objects-v2 \
              --bucket ${{ secrets.R2_BUCKET_NAME }} \
              --prefix "${service}-" \
              --endpoint-url ${{ secrets.R2_ENDPOINT }} \
              --query 'Contents[].Key' \
              --output text | tr '\t' '\n' | while read -r file_key; do

              # Check if this file matches the service-major pattern
              if [[ "$file_key" =~ ^${service}-[0-9]+\. ]] && [[ "$file_key" =~ -macos-.*\.tar\.xz$ ]]; then
                # Extract version from filename to check if it matches our major version
                file_version=$(echo "$file_key" | sed -E "s/^${service}-([0-9]+(\.[0-9]+){1,2})-.*/\1/")
                file_major=$(echo "$file_version" | cut -d. -f1)

                if [[ "$file_major" == "$major" ]] && [[ "$file_key" != "$CURRENT_FILENAME" ]]; then
                  echo "  Deleting old build: $file_key"
                  aws s3 rm s3://${{ secrets.R2_BUCKET_NAME }}/"$file_key" \
                    --endpoint-url ${{ secrets.R2_ENDPOINT }} || echo "  Failed to delete $file_key"
                fi
              fi
            done
          done

          echo "Cleanup completed"
