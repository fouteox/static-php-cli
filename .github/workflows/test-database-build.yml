name: "Test - Database Build"

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to build (mysql, postgresql, mariadb, or all)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - mysql
          - postgresql
          - mariadb

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  OPENSSL_VERSION: "3.5.3"

jobs:
  fetch-versions:
    name: "Fetch database versions"
    runs-on: ubuntu-latest
    outputs:
      build-matrix: ${{ steps.versions.outputs.matrix }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Fetch versions for all selected services"
        id: versions
        run: |
          SERVICE_INPUT="${{ github.event.inputs.service || 'all' }}"

          # Determine which services to process
          if [[ "$SERVICE_INPUT" == "all" ]]; then
            SERVICES=("mysql" "postgresql" "mariadb")
          else
            SERVICES=("$SERVICE_INPUT")
          fi

          # Source the centralized config
          source .github/config/services-config.sh

          # Build combined matrix
          all_items=()

          for SERVICE in "${SERVICES[@]}"; do
            echo "Fetching versions for $SERVICE..."

            # Fetch releases from endoflife.date API
            response=$(curl -s "https://endoflife.date/api/${SERVICE}.json")

            # Get supported major versions from config
            major_versions=$(get_supported_versions "$SERVICE")

            # Extract latest version for each major version
            for major in $major_versions; do
              # PostgreSQL uses exact cycle match, others use startswith
              if [[ "$SERVICE" == "postgresql" ]]; then
                version=$(echo "$response" | jq -r "[.[] | select(.cycle == \"$major\") | select(.eol == false or (.eol | type) == \"string\")] | sort_by(.releaseDate) | reverse | .[0].latest")
              else
                version=$(echo "$response" | jq -r "[.[] | select(.cycle | startswith(\"$major.\")) | select(.eol == false or (.eol | type) == \"string\")] | sort_by(.releaseDate) | reverse | .[0].latest")
              fi

              if [[ "$version" != "null" && -n "$version" ]]; then
                all_items+=("{\"service\": \"$SERVICE\", \"version\": \"$version\"}")
                echo "  ${SERVICE^} $major: $version"
              fi
            done
          done

          # Build combined matrix JSON
          matrix_items=$(printf '%s,' "${all_items[@]}" | sed 's/,$//')
          matrix=$(echo "{\"include\": [$matrix_items]}" | jq -c)

          echo "matrix=$matrix" >> $GITHUB_OUTPUT
          echo "Generated combined matrix: $matrix"

  build-openssl:
    name: "Build OpenSSL static library"
    runs-on: macos-latest
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Cache OpenSSL build"
        id: cache-openssl
        uses: actions/cache@v4
        with:
          path: /tmp/openssl-static
          key: openssl-${{ env.OPENSSL_VERSION }}-macos-arm64

      - name: "Build OpenSSL ${{ env.OPENSSL_VERSION }}"
        if: steps.cache-openssl.outputs.cache-hit != 'true'
        run: |
          OPENSSL_DIR="/tmp/openssl-static"
          OPENSSL_VERSION="${{ env.OPENSSL_VERSION }}"
          mkdir -p "$OPENSSL_DIR"

          curl -fsSL -o "openssl-${OPENSSL_VERSION}.tar.gz" "https://www.openssl.org/source/openssl-${OPENSSL_VERSION}.tar.gz"
          tar xzf "openssl-${OPENSSL_VERSION}.tar.gz"
          cd "openssl-${OPENSSL_VERSION}"

          ./Configure darwin64-arm64-cc \
            --prefix="$OPENSSL_DIR" \
            --openssldir="$OPENSSL_DIR" \
            shared \
            no-tests \
            no-docs \
            no-atexit

          make
          make install_sw

  build-service:
    name: "Build ${{ matrix.service }} ${{ matrix.version }}"
    runs-on: macos-latest
    needs: [fetch-versions, build-openssl]
    timeout-minutes: 240
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      PREBUILT_OPENSSL_DIR: /tmp/openssl-static
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.fetch-versions.outputs.build-matrix) }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Restore OpenSSL from cache"
        uses: actions/cache@v4
        with:
          path: /tmp/openssl-static
          key: openssl-${{ env.OPENSSL_VERSION }}-macos-arm64

      - name: "Setup dependencies"
        if: matrix.service == 'mysql' || matrix.service == 'mariadb'
        run: |
          brew install bison pkg-config ninja

      - name: "Generate Build Timestamp"
        id: timestamp
        run: |
          echo "timestamp=$(date -u +"%Y%m%d%H%M%S")" >> $GITHUB_OUTPUT

      - name: "Build ${{ matrix.service }}"
        run: |
          .github/scripts/database-build.sh ${{ matrix.service }} ${{ matrix.version }}

      - name: "Upload archive to R2"
        run: |
          SERVICE="${{ matrix.service }}"
          VERSION="${{ matrix.version }}"
          ARCH=$(uname -m)
          WORKDIR="$HOME/fadogen-build/${SERVICE}-${VERSION}"
          ORIGINAL_ARCHIVE="$WORKDIR/${SERVICE}-${VERSION}-macos-${ARCH}.tar.xz"

          if [[ ! -f "$ORIGINAL_ARCHIVE" ]]; then
            echo "[ERROR] Archive not found: $ORIGINAL_ARCHIVE"
            exit 1
          fi

          TIMESTAMP="${{ steps.timestamp.outputs.timestamp }}"
          ARCHIVE_NAME="${SERVICE}-${VERSION}-macos-${ARCH}-${TIMESTAMP}.tar.xz"
          cp "$ORIGINAL_ARCHIVE" "$ARCHIVE_NAME"

          if command -v sha512sum >/dev/null 2>&1; then
            SHA512=$(sha512sum "$ARCHIVE_NAME" | awk '{print $1}')
          else
            SHA512=$(shasum -a 512 "$ARCHIVE_NAME" | awk '{print $1}')
          fi

          echo "Archive: $ARCHIVE_NAME ($(du -h "$ARCHIVE_NAME" | cut -f1))"
          echo "SHA512: $SHA512"

          aws s3 cp "$ARCHIVE_NAME" \
            s3://${{ secrets.R2_BUCKET_NAME }}/"$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }}
