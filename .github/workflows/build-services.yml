name: "Build Services"

on:
  schedule:
    - cron: '0 0,12 * * *'  # Every 12 hours (midnight and noon UTC)
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  OPENSSL_MAJOR_MINOR: "3.5"

jobs:
  check-and-sync:
    name: "Check service versions and sync"
    runs-on: ubuntu-latest
    outputs:
      build-matrix: ${{ steps.check.outputs.build-matrix }}
      should-build: ${{ steps.check.outputs.should-build }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download metadata-services.json from R2"
        id: download-metadata
        run: |
          if aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "Downloaded existing metadata-services.json"
          else
            echo "{}" > metadata-services.json
            echo "Created empty metadata-services.json"
          fi

      - name: "Check versions and generate build matrix"
        id: check
        run: |
          .github/scripts/services-metadata-manager.sh check-versions

  resolve-openssl:
    name: "Resolve OpenSSL version"
    runs-on: ubuntu-latest
    needs: [check-and-sync]
    if: needs.check-and-sync.outputs.should-build == 'true'
    outputs:
      openssl-version: ${{ steps.resolve.outputs.version }}
    steps:
      - name: "Resolve latest OpenSSL ${{ env.OPENSSL_MAJOR_MINOR }}"
        id: resolve
        run: |
          MAJOR_MINOR="${{ env.OPENSSL_MAJOR_MINOR }}"
          LATEST=$(curl -s "https://endoflife.date/api/openssl.json" | \
            jq -r ".[] | select(.cycle == \"$MAJOR_MINOR\") | .latest")

          if [[ -z "$LATEST" || "$LATEST" == "null" ]]; then
            echo "Failed to resolve OpenSSL version for $MAJOR_MINOR"
            exit 1
          fi

          echo "version=$LATEST" >> $GITHUB_OUTPUT
          echo "Resolved OpenSSL $MAJOR_MINOR -> $LATEST"

  build-openssl:
    name: "Build OpenSSL ${{ needs.resolve-openssl.outputs.openssl-version }}"
    runs-on: macos-latest
    needs: [resolve-openssl]
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Cache OpenSSL build"
        id: cache-openssl
        uses: actions/cache@v4
        with:
          path: /tmp/openssl-static
          key: openssl-${{ needs.resolve-openssl.outputs.openssl-version }}-macos-arm64

      - name: "Build OpenSSL ${{ needs.resolve-openssl.outputs.openssl-version }}"
        if: steps.cache-openssl.outputs.cache-hit != 'true'
        run: |
          OPENSSL_DIR="/tmp/openssl-static"
          OPENSSL_VERSION="${{ needs.resolve-openssl.outputs.openssl-version }}"
          mkdir -p "$OPENSSL_DIR"

          curl -fsSL -o "openssl-${OPENSSL_VERSION}.tar.gz" "https://www.openssl.org/source/openssl-${OPENSSL_VERSION}.tar.gz"
          tar xzf "openssl-${OPENSSL_VERSION}.tar.gz"
          cd "openssl-${OPENSSL_VERSION}"

          ./Configure darwin64-arm64-cc \
            --prefix="$OPENSSL_DIR" \
            --openssldir="$OPENSSL_DIR" \
            shared \
            no-tests \
            no-docs \
            no-atexit

          make
          make install_sw

  build-service:
    name: "Build ${{ matrix.service }} ${{ matrix.version }}"
    runs-on: macos-latest
    needs: [check-and-sync, resolve-openssl, build-openssl]
    if: needs.check-and-sync.outputs.should-build == 'true'
    timeout-minutes: 240
    continue-on-error: true
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      PREBUILT_OPENSSL_DIR: /tmp/openssl-static
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.check-and-sync.outputs.build-matrix) }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Restore OpenSSL from cache"
        uses: actions/cache@v4
        with:
          path: /tmp/openssl-static
          key: openssl-${{ needs.resolve-openssl.outputs.openssl-version }}-macos-arm64

      - name: "Setup dependencies"
        run: |
          # Function to install Homebrew packages only if not already installed
          brew_install_if_missing() {
            for package in "$@"; do
              if ! brew list --formula "$package" >/dev/null 2>&1; then
                echo "Installing $package..."
                brew install "$package"
              else
                echo "$package is already installed, skipping"
              fi
            done
          }

          # MySQL and MariaDB need bison and ninja
          if [[ "${{ matrix.service }}" == "mysql" || "${{ matrix.service }}" == "mariadb" ]]; then
            brew_install_if_missing bison pkg-config ninja
          fi

          # Redis and Valkey need GNU tools and Rust
          if [[ "${{ matrix.service }}" == "redis" || "${{ matrix.service }}" == "valkey" ]]; then
            brew_install_if_missing coreutils make llvm@18 cmake gnu-sed automake libtool wget rust
          fi

      - name: "Generate Build Timestamp"
        id: timestamp
        run: |
          echo "timestamp=$(date -u +"%Y%m%d%H%M%S")" >> $GITHUB_OUTPUT

      - name: "Build ${{ matrix.service }}"
        run: |
          .github/scripts/service-build.sh ${{ matrix.service }} ${{ matrix.version }}

      - name: "Upload archive to R2 with SHA-256 checksum"
        run: |
          SERVICE="${{ matrix.service }}"
          VERSION="${{ matrix.version }}"
          MAJOR="${{ matrix.major }}"
          ARCH=$(uname -m)
          WORKDIR="$HOME/fadogen-build/${SERVICE}-${VERSION}"
          ORIGINAL_ARCHIVE="$WORKDIR/${SERVICE}-${VERSION}-macos-${ARCH}.tar.xz"

          if [[ ! -f "$ORIGINAL_ARCHIVE" ]]; then
            echo "[ERROR] Archive not found: $ORIGINAL_ARCHIVE"
            exit 1
          fi

          TIMESTAMP="${{ steps.timestamp.outputs.timestamp }}"
          ARCHIVE_NAME="${SERVICE}-${VERSION}-macos-${ARCH}-${TIMESTAMP}.tar.xz"
          cp "$ORIGINAL_ARCHIVE" "$ARCHIVE_NAME"

          echo "Uploading: $ARCHIVE_NAME ($(du -h "$ARCHIVE_NAME" | cut -f1))"

          # Upload with native SHA-256 checksum (captures checksum in response)
          UPLOAD_RESULT=$(aws s3api put-object \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --key "$ARCHIVE_NAME" \
            --body "$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --checksum-algorithm SHA256 \
            --metadata service="$SERVICE",version="$VERSION",major="$MAJOR" \
            --output json)

          # Extract checksum from upload response and convert to hex
          CHECKSUM_BASE64=$(echo "$UPLOAD_RESULT" | jq -r '.ChecksumSHA256')
          CHECKSUM_HEX=$(echo "$CHECKSUM_BASE64" | base64 -d | xxd -p -c 256)

          echo "✓ Uploaded: $ARCHIVE_NAME"
          echo "✓ SHA-256: $CHECKSUM_HEX"

          # Save checksum info (format: service,version,major,sha256,filename)
          echo "${SERVICE},${VERSION},${MAJOR},${CHECKSUM_HEX},${ARCHIVE_NAME}" > checksum-${SERVICE}-${VERSION}.txt
          echo "Checksum saved: ${SERVICE},${VERSION},${MAJOR},${CHECKSUM_HEX},${ARCHIVE_NAME}"

      - name: "Upload checksum info"
        uses: actions/upload-artifact@v4
        with:
          name: checksum-${{ matrix.service }}-${{ matrix.version }}
          path: checksum-${{ matrix.service }}-${{ matrix.version }}.txt
          retention-days: 1

  update-metadata:
    name: "Update metadata-services.json"
    runs-on: ubuntu-latest
    needs: [check-and-sync, build-service]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download metadata-services.json from R2"
        run: |
          if aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "Downloaded existing metadata-services.json"
          else
            echo "{}" > metadata-services.json
            echo "Created empty metadata-services.json"
          fi

      - name: "Download all checksum artifacts"
        uses: actions/download-artifact@v5
        with:
          pattern: checksum-*
          merge-multiple: true

      - name: "Update metadata"
        run: |
          # Consolidate all checksums from successful builds
          ALL_CHECKSUMS=$(cat checksum-*.txt 2>/dev/null | grep -v "^$")

          # Update metadata (format: service,version,major,sha256,filename)
          echo "$ALL_CHECKSUMS" | .github/scripts/services-metadata-manager.sh update-metadata

          # Display updated metadata
          echo "=== Updated metadata-services.json ==="
          cat metadata-services.json

      - name: "Upload metadata-services.json to R2"
        run: |
          aws s3 cp metadata-services.json s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }}
          echo "Uploaded metadata-services.json to R2"

  cleanup-old-builds:
    name: "Cleanup old service builds"
    runs-on: ubuntu-latest
    needs: [update-metadata]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download updated metadata-services.json from R2"
        run: |
          aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }}
          echo "Downloaded updated metadata-services.json"

      - name: "Cleanup old builds"
        run: |
          echo "Starting cleanup of old service builds..."

          # Extract service-major pairs from metadata (only successful builds are in metadata)
          jq -r 'to_entries[] | .key as $service | .value | to_entries[] | "\($service),\(.key)"' metadata-services.json | sort -u | while IFS=',' read -r service major; do
            echo "Cleaning up old builds for $service major version $major..."

            # Get the current filename from metadata
            CURRENT_FILENAME=$(jq -r ".\"$service\".\"$major\".filename // \"\"" metadata-services.json)

            if [[ -z "$CURRENT_FILENAME" ]]; then
              echo "  No current filename found in metadata for $service $major"
              continue
            fi

            echo "  Current file: $CURRENT_FILENAME"

            # List all files for this service-major pattern and delete all except the current one
            aws s3api list-objects-v2 \
              --bucket ${{ secrets.R2_BUCKET_NAME }} \
              --prefix "${service}-" \
              --endpoint-url ${{ secrets.R2_ENDPOINT }} \
              --query 'Contents[].Key' \
              --output text | tr '\t' '\n' | while read -r file_key; do

              # Check if this file matches the service-major pattern
              if [[ "$file_key" =~ ^${service}-[0-9]+\. ]] && [[ "$file_key" =~ -macos-.*\.tar\.xz$ ]]; then
                # Extract version from filename to check if it matches our major version
                file_version=$(echo "$file_key" | sed -E "s/^${service}-([0-9]+(\.[0-9]+){1,2})-.*/\1/")
                file_major=$(echo "$file_version" | cut -d. -f1)

                if [[ "$file_major" == "$major" ]] && [[ "$file_key" != "$CURRENT_FILENAME" ]]; then
                  echo "  Deleting old build: $file_key"
                  aws s3 rm s3://${{ secrets.R2_BUCKET_NAME }}/"$file_key" \
                    --endpoint-url ${{ secrets.R2_ENDPOINT }} || echo "  Failed to delete $file_key"
                fi
              fi
            done
          done

          echo "Cleanup completed"
