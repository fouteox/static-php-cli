name: "Test Build Services (Homebrew Bottles - Valkey Only)"

on:
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  check-and-sync:
    name: "Check service versions and sync"
    runs-on: macos-latest
    outputs:
      build-matrix: ${{ steps.check.outputs.build-matrix }}
      should-build: ${{ steps.check.outputs.should-build }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Update Homebrew"
        run: |
          brew update

      - name: "Download metadata-services.json from R2"
        id: download-metadata
        run: |
          if ! aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "{}" > metadata-services.json
          fi

      - name: "Check versions and generate build matrix"
        id: check
        env:
          FILTER_SERVICE: valkey
        run: |
          # Generate matrix for valkey only
          .github/scripts/services-metadata-manager.sh check-versions

  build-service:
    name: "Build ${{ matrix.service }} ${{ matrix.version }}"
    runs-on: macos-latest
    needs: [check-and-sync]
    if: needs.check-and-sync.outputs.should-build == 'true'
    timeout-minutes: 60
    continue-on-error: true
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      SIGNING_IDENTITY: ${{ secrets.SIGNING_IDENTITY }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.check-and-sync.outputs.build-matrix) }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Update Homebrew"
        run: |
          brew update

      - name: "Import Apple Code Signing Certificate"
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Decode certificate
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $RUNNER_TEMP/build_certificate.p12

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

          # Set as default keychain (CRITICAL for codesign to find identity)
          security default-keychain -s $RUNNER_TEMP/app-signing.keychain-db

          security set-keychain-settings -lut 21600 $RUNNER_TEMP/app-signing.keychain-db
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

          # Import certificate with explicit codesign access
          security import $RUNNER_TEMP/build_certificate.p12 \
            -P "$P12_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k $RUNNER_TEMP/app-signing.keychain-db \
            -T /usr/bin/codesign

          security list-keychain -d user -s $RUNNER_TEMP/app-signing.keychain-db

          # Allow codesign to access keychain without password prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

          # Verify identity is available
          echo "Available code signing identities:"
          security find-identity -v -p codesigning

      - name: "Build ${{ matrix.service }} via Homebrew"
        run: |
          ./create-portable-package.sh "${{ matrix.formula }}"

      - name: "Upload archive to R2 with SHA-256 checksum"
        run: |
          SERVICE="${{ matrix.service }}"
          VERSION="${{ matrix.version }}"
          MAJOR="${{ matrix.major }}"
          ARCHIVE_NAME="${SERVICE}-${VERSION}.tar.gz"

          if [[ ! -f "$ARCHIVE_NAME" ]]; then
            echo "[ERROR] Archive not found: $ARCHIVE_NAME"
            exit 1
          fi

          # Upload with native SHA-256 checksum (captures checksum in response)
          UPLOAD_RESULT=$(aws s3api put-object \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --key "$ARCHIVE_NAME" \
            --body "$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --checksum-algorithm SHA256 \
            --metadata service="$SERVICE",version="$VERSION",major="$MAJOR" \
            --output json)

          # Extract checksum from upload response and convert to hex
          CHECKSUM_BASE64=$(echo "$UPLOAD_RESULT" | jq -r '.ChecksumSHA256')
          CHECKSUM_HEX=$(echo "$CHECKSUM_BASE64" | base64 -d | xxd -p -c 256)

          echo "✓ Uploaded $ARCHIVE_NAME (SHA-256: $CHECKSUM_HEX)"

          # Save checksum info (format: service,version,major,sha256,filename)
          echo "${SERVICE},${VERSION},${MAJOR},${CHECKSUM_HEX},${ARCHIVE_NAME}" > checksum-${SERVICE}-${VERSION}.txt

      - name: "Upload checksum info"
        uses: actions/upload-artifact@v4
        with:
          name: checksum-${{ matrix.service }}-${{ matrix.version }}
          path: checksum-${{ matrix.service }}-${{ matrix.version }}.txt
          retention-days: 1

      - name: "Cleanup Keychain"
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
          rm -f $RUNNER_TEMP/build_certificate.p12 || true

  update-metadata:
    name: "Update metadata-services.json"
    runs-on: ubuntu-latest
    needs: [check-and-sync, build-service]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download metadata-services.json from R2"
        run: |
          if ! aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "{}" > metadata-services.json
          fi

      - name: "Download all checksum artifacts"
        uses: actions/download-artifact@v5
        with:
          pattern: checksum-*
          merge-multiple: true

      - name: "Update metadata"
        run: |
          # Consolidate all checksums from successful builds
          ALL_CHECKSUMS=$(cat checksum-*.txt 2>/dev/null | grep -v "^$")

          # Update metadata (format: service,version,major,sha256,filename)
          echo "$ALL_CHECKSUMS" | .github/scripts/services-metadata-manager.sh update-metadata

      - name: "Upload metadata-services.json to R2"
        run: |
          aws s3 cp metadata-services.json s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null
          echo "✓ Metadata updated"

  cleanup-old-builds:
    name: "Cleanup old service builds"
    runs-on: ubuntu-latest
    needs: [update-metadata]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download updated metadata-services.json from R2"
        run: |
          aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-services.json metadata-services.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null

      - name: "Cleanup old builds"
        run: |
          # Extract service-major pairs from metadata (only successful builds are in metadata)
          jq -r 'to_entries[] | .key as $service | .value | to_entries[] | "\($service),\(.key)"' metadata-services.json | sort -u | while IFS=',' read -r service major; do
            # Get the current filename from metadata
            CURRENT_FILENAME=$(jq -r ".\"$service\".\"$major\".filename // \"\"" metadata-services.json)

            if [[ -z "$CURRENT_FILENAME" ]]; then
              continue
            fi

            # List all files for this service-major and delete all except the current one
            DELETED=0
            aws s3api list-objects-v2 \
              --bucket ${{ secrets.R2_BUCKET_NAME }} \
              --prefix "${service}-${major}." \
              --endpoint-url ${{ secrets.R2_ENDPOINT }} \
              --query 'Contents[].Key' \
              --output text | tr '\t' '\n' | while read -r file_key; do
              if [[ "$file_key" != "$CURRENT_FILENAME" ]] && [[ "$file_key" != "None" ]] && [[ -n "$file_key" ]]; then
                aws s3 rm s3://${{ secrets.R2_BUCKET_NAME }}/"$file_key" --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null 2>&1 && DELETED=$((DELETED + 1))
              fi
            done

            [[ $DELETED -gt 0 ]] && echo "✓ Cleaned $DELETED old builds for $service $major"
          done
