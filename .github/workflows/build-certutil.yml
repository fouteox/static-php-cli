name: "Build certutil"

on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  check-nss-version:
    name: "Check NSS version"
    runs-on: macos-latest
    outputs:
      should-build: ${{ steps.check.outputs.should-build }}
      nss-version: ${{ steps.check.outputs.nss-version }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Update Homebrew"
        run: |
          echo "Updating Homebrew..."
          brew update >/dev/null 2>&1
          echo "✓ Homebrew updated"

      - name: "Download metadata-certutil.json from R2"
        id: download-metadata
        run: |
          if ! aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-certutil.json metadata-certutil.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "{}" > metadata-certutil.json
            echo "Created empty metadata-certutil.json"
          else
            echo "Downloaded existing metadata-certutil.json"
          fi

      - name: "Check NSS version"
        id: check
        run: |
          # Get current NSS version from Homebrew
          NSS_VERSION=$(brew info nss --json=v2 | jq -r '.formulae[0].versions.stable')
          echo "Homebrew NSS version: $NSS_VERSION"

          # Get version from metadata
          METADATA_VERSION=$(jq -r '.latest // ""' metadata-certutil.json)
          echo "Metadata version: ${METADATA_VERSION:-none}"

          # Compare versions
          if [[ "$NSS_VERSION" != "$METADATA_VERSION" ]]; then
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "nss-version=$NSS_VERSION" >> $GITHUB_OUTPUT
            if [[ -z "$METADATA_VERSION" ]]; then
              echo "✓ New: NSS $NSS_VERSION (initial build)"
            else
              echo "✓ Update: NSS $NSS_VERSION (was: $METADATA_VERSION)"
            fi
          else
            echo "should-build=false" >> $GITHUB_OUTPUT
            echo "nss-version=$NSS_VERSION" >> $GITHUB_OUTPUT
            echo "→ NSS $NSS_VERSION already built, skipping"
          fi

  build-certutil:
    name: "Build certutil (NSS ${{ needs.check-nss-version.outputs.nss-version }})"
    runs-on: macos-latest
    needs: [check-nss-version]
    if: needs.check-nss-version.outputs.should-build == 'true'
    timeout-minutes: 30
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
      SIGNING_IDENTITY: ${{ secrets.SIGNING_IDENTITY }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Update Homebrew"
        run: |
          echo "Updating Homebrew..."
          brew update >/dev/null 2>&1
          echo "✓ Homebrew updated"

      - name: "Import Apple Code Signing Certificate"
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Decode certificate
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $RUNNER_TEMP/build_certificate.p12

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

          # Set as default keychain (CRITICAL for codesign to find identity)
          security default-keychain -s $RUNNER_TEMP/app-signing.keychain-db

          security set-keychain-settings -lut 21600 $RUNNER_TEMP/app-signing.keychain-db
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

          # Import certificate with explicit codesign access
          security import $RUNNER_TEMP/build_certificate.p12 \
            -P "$P12_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k $RUNNER_TEMP/app-signing.keychain-db \
            -T /usr/bin/codesign

          security list-keychain -d user -s $RUNNER_TEMP/app-signing.keychain-db

          # Allow codesign to access keychain without password prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db

      - name: "Build certutil via create-nss-package.sh"
        run: |
          .github/scripts/create-nss-package.sh

      - name: "Upload archive to R2 with SHA-256 checksum"
        run: |
          VERSION="${{ needs.check-nss-version.outputs.nss-version }}"
          ARCHIVE_NAME="nss-${VERSION}.tar.gz"

          if [[ ! -f "$ARCHIVE_NAME" ]]; then
            echo "[ERROR] Archive not found: $ARCHIVE_NAME"
            exit 1
          fi

          # Upload with native SHA-256 checksum (R2 calculates and returns checksum)
          UPLOAD_RESULT=$(aws s3api put-object \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --key "$ARCHIVE_NAME" \
            --body "$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --checksum-algorithm SHA256 \
            --metadata service="certutil",nss_version="$VERSION" \
            --output json)

          # Extract checksum from upload response and convert to hex
          CHECKSUM_BASE64=$(echo "$UPLOAD_RESULT" | jq -r '.ChecksumSHA256')
          CHECKSUM_HEX=$(echo "$CHECKSUM_BASE64" | base64 -d | xxd -p -c 256)

          echo "✓ Uploaded $ARCHIVE_NAME (SHA-256: $CHECKSUM_HEX)"

          # Save checksum info (format: version,sha256,filename)
          echo "${VERSION},${CHECKSUM_HEX},${ARCHIVE_NAME}" > checksum-certutil.txt

      - name: "Upload checksum info"
        uses: actions/upload-artifact@v4
        with:
          name: checksum-certutil
          path: checksum-certutil.txt
          retention-days: 1

      - name: "Cleanup Keychain"
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
          rm -f $RUNNER_TEMP/build_certificate.p12 || true

  update-metadata:
    name: "Update metadata-certutil.json"
    runs-on: ubuntu-latest
    needs: [check-nss-version, build-certutil]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download checksum artifact"
        uses: actions/download-artifact@v5
        with:
          name: checksum-certutil

      - name: "Update metadata"
        run: |
          # Read checksum info (format: version,sha256,filename)
          IFS=',' read -r VERSION SHA256 FILENAME < checksum-certutil.txt

          # Create metadata-certutil.json
          jq -n \
            --arg latest "$VERSION" \
            --arg sha256 "$SHA256" \
            --arg filename "$FILENAME" \
            '{
              "latest": $latest,
              "sha256": $sha256,
              "filename": $filename
            }' > metadata-certutil.json

          echo "Created metadata-certutil.json:"
          cat metadata-certutil.json

      - name: "Upload metadata-certutil.json to R2"
        run: |
          aws s3 cp metadata-certutil.json s3://${{ secrets.R2_BUCKET_NAME }}/metadata-certutil.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null
          echo "✓ Metadata updated"

  cleanup-old-builds:
    name: "Cleanup old certutil builds"
    runs-on: ubuntu-latest
    needs: [update-metadata]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v5

      - name: "Download updated metadata-certutil.json from R2"
        run: |
          aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-certutil.json metadata-certutil.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null

      - name: "Cleanup old builds"
        run: |
          # Extract current filename from metadata
          CURRENT_FILENAME=$(jq -r '.filename' metadata-certutil.json)

          echo "Current build: $CURRENT_FILENAME"

          # List all nss-*.tar.gz files and delete all except the current one
          aws s3api list-objects-v2 \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --prefix "nss-" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --query 'Contents[].Key' \
            --output text 2>/dev/null | tr '\t' '\n' | while read -r file_key; do
            case "$file_key" in
              nss-*.tar.gz)
                if [ "$file_key" != "$CURRENT_FILENAME" ] && [ -n "$file_key" ]; then
                  if aws s3 rm s3://${{ secrets.R2_BUCKET_NAME }}/"$file_key" --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null 2>&1; then
                    echo "✓ Deleted old build: $file_key"
                  fi
                fi
                ;;
            esac
          done

          echo "✓ Cleanup completed"
